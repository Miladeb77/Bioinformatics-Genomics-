# finding the donor position
dna= input("please give me a DNA sequence: ")
donor= dna.find("GT",0)
while donor> -1:
    print("the donor site position is ", donor+1,donor+2)
    donor=dna.find("GT",donor+1)
    
#finding valid aminoacids in a protein sequence
protein_seq= input("please give me a protein seqence")
valids= "ABC"
for i in range(len(protein_seq)):
    if protein_seq[i] not in valids:
        print("protein contains invalid amino aicd at position",i," and the amino acid is" ,protein_seq[i])
        
        
# a clinical project :

A= input('responsive to cold?')
if A== 'yes':
    B= input('pain or discomfort?')
    if B== 'no':
        print('normal')
    elif B== 'yes':
        C= input('does it linger?')
        if C== 'yes':
            print('symptomatic irreversible pulpitis')
        elif C== 'no':
            print('reversible pulpitis')
        else:
            print('error')
            C= input('does it linger?')
    else:
        print('error')
        B= input('pain or discomfort?')
elif A== 'no':
    D= input('do control teeth respond similarly?')
    if D== 'no':
        print('pulpal necrosis')
    elif D== 'yes':
        print('nonresponsive, retest using EPT')
    else: 
        print('error')
        D= input('do control teeth respond similarly?')
else:
    print('error')
    A= input('responsive to cold?')
    
  ############################################################  
    
def reading_file(path):
    return open(path,'r')

def record_count(path):
    f= reading_file(path)
    record_count= 0
    # the number of records:
    for line in f:
        if line[0]== '>':
            record_count+= 1
    print(record_count)  

def file_to_dict(path):
    f= reading_file(path)
    seqs={}
    name= ''
    for line in f:
        # discarding any new line at the end
        line= line.rstrip()
        #distinquishing header from the sequence
        if line[0]== '>':
            #spliting the line into words so that we could get our key for the dictionary
            words= line.split() # spliting is based on space by default
            #building the key for dictionary and the key is the first word of the identifier line 
            name= words[0][1: ]
            #identifying the key and setting an empty value for it 
            seqs[name]= ''
        else: # for those lines that are not the header and re the lines for the sequences
            seqs[name]= seqs[name]+ line
    return seqs

def sequence_length(path):
    seqs= file_to_dict(path)
    min_len = 999999999  # initialize with a large value
    min_values = []
    min_keys = []
    for key, value in seqs.items():
        if len(value) < min_len:
            min_len = len(value)
            min_values = [value]
            min_keys = [key]
        elif len(value) == min_len:
            min_values.append(value)
            min_keys.append(key)
    print("Minimum length:", min_len)
    print("Keys with minimum length:", min_keys)
   # print("Values with minimum length:", min_values)
    # Initialize variables to keep track of key and value with longest string
    longest_value = ""
    longest_key = ""
 # Iterate through each key-value pair in the dictionary
    for key, value in seqs.items():
        # Check if the length of the value is greater than the current longest value
        if len(value) > len(longest_value):
            # If so, update the longest value and key
            longest_value = value
            longest_key = key
        # If the length of the value is the same as the current longest value, add the key to a list of keys with longest value
        elif len(value) == len(longest_value):
            longest_key.append(key)
 # Print the key and value with the longest string
    print("Key(s) with longest value:", longest_key)
    print("Longest value:", longest_value)
    
def repeats(path,n):
    FASTA_seqs= file_to_dict(path)
    repeats= {}
    for header,sequence in FASTA_seqs.items():
        for i in range(len(sequence) -n +1):
            repeat= sequence[i:i+n]
            if repeat not in repeats:
                repeats[repeat]= 1
            else:
                repeats[repeat]+= 1
    # the most frequent repeat:
    max_repeat= ""
    max_repeat_count= 0
    for repeat,count in repeats.items():
        if count > max_repeat_count:
            max_repeat= repeat
            max_repeat_count= count
    print(repeats, max_repeat, max_repeat_count)

def ORF(path):
    seqs= file_to_dict(path)
    #building the ORFs:
    startA= 'ATG'
    stopA= ['TAA','TAG','TGA']
    ORFs= {}
    for key,value in seqs.items():
        ORFs[key]= []
        for s in range(0,2):
            for i in range(s,len(value),3):
                Flag= False
                codon= value[i:i+3]
                if codon== startA:
                    for J in range(i+3,len(value),3):
                        codon= value[J:J+3]
                        if codon in stopA:
                            ORFs[key].append(value[i:J+3])
                            Flag= True
                            break
                if Flag:
                    break
    return ORFs

def find_ORF_details(path):
    ORFs= ORF(path)
    ORF_details= {}
    for key,value in ORFs.items():
        max_len_ORF= 0
        max_NUM= 0
        max_value= ''
        for i in range(len(value)):
            if len(value[i]) > max_len_ORF:
                max_NUM= i
                max_len_ORF= len(value[i])
                max_value= value[i]
        ORF_details[key]= {"max_len_ORF":max_len_ORF,"max_NUM": max_NUM, "max_value": max_value}
    return ORF_details    

